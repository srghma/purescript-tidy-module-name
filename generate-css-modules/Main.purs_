module Main where

import Prelude

import AppOptions (GlobalAndCommandOptions, commandOptionsToCommandShort, commandOptionsToTargetDirectoriesOptions, globalAndCommandOptions_color, globalAndCommandOptions_command)
import Control.Parallel (parTraverse, parTraverse_)
import CssContentToTypes (cssContentToTypes)
import Data.Array (length)
import Data.Array as Array
import Data.Either (Either(..))
import Data.Foldable (traverse_)
import Data.Maybe (Maybe(..))
import Data.NonEmpty (NonEmpty)
import Data.NonEmpty as NonEmpty
import Data.String as String
import Data.Traversable (traverse)
import Effect (Effect)
import Effect.Aff (Aff, launchAff_)
import Effect.Class (liftEffect)
import Effect.Console as Console
import Logger (Logger, makeLogger, withConcurrentLogger)
import ModuleName (ModuleName, unModuleName)
import Node.Encoding (Encoding(..))
import Node.FS.Aff as FS
import Node.Path (FilePath)
import Node.Path as Path
import Node.Process as Process
import Options.Applicative (ParserInfo, execParser, fullDesc, header, helper, info, progDesc, (<**>))
import Text.Colour as Colour
import Text.Colour.Chunk (Chunk)
import UpdateModuleName (UpdateModuleNameResult(..))
import Utils (ensureDirsExist, findFilesWith, fullPathToModuleName, isCssModuleFile)

appOptionsParserInfo :: ParserInfo GlobalAndCommandOptions
appOptionsParserInfo = info (globalAndCommandOptionsParser <**> helper)
  ( fullDesc
  <> progDesc "Halogen FFI generator for webpack css modules"
  <> header "Finds Anyname.module.css, generates Anyname.purs and Anyname.js files" )

main :: Effect Unit
main = launchAff_ do
  globalAndCommandOptions <- liftEffect $ execParser appOptionsParserInfo

  let
    color = globalAndCommandOptions_color globalAndCommandOptions
    commandShort = commandOptionsToCommandShort $ globalAndCommandOptions_command globalAndCommandOptions
    targetDirectoriesOptions = commandOptionsToTargetDirectoriesOptions $ globalAndCommandOptions_command globalAndCommandOptions

  logger <- liftEffect $ makeLogger color

  directoryConfig <- targetDirectoriesOptionsToDirectoryConfigOrCwd targetDirectoriesOptions

  let
    dirsThatRequiredToBePresent = collectRequiredDirs directoryConfig

  traverse_ ensureDirsExist dirsThatRequiredToBePresent

  baseDirs <- parTraverse (\config -> do
    let baseDir = directoryConfig_pathToDirectory config
    files <- findFilesWith isCssModuleFile baseDir
    pure $ Tuple baseDir files
  ) directoryConfig

  withConcurrentLogger logger \concurrentLogger ->
    parTraverse_ (\(Tuple baseDir filePaths) ->
      parTraverse_ (processFile concurrentLogger baseDir) filePaths
    ) baseDirs

processFile :: (Logger -> Aff Unit) -> FilePath -> FilePath -> Aff Unit
processFile concurrentLogger baseDir filePath = do
  let
    log :: Array Chunk -> Aff Unit
    log = concurrentLogger <<< Log <<< Colour.unlinesChunks

  log
    [ Colour.fore Colour.green "processing "
    , Colour.fore Colour.yellow filePath
    ]

  cssFileContent <- FS.readTextFile UTF8 filePath

  let classNames = cssContentToTypes cssFileContent

  moduleName <- fullPathToModuleName baseDir filePath

  let
    moduleName_lastPart = NonEmpty.last $ unModuleName moduleName
    makeFile ext = Path.concat
      [ Path.dirname filePath
      , Path.basenameWithoutExt moduleName_lastPart "." <> "." <> ext
      ]
    jsFilePath = makeFile "js"
    pursFilePath = makeFile "purs"

  log [ Colour.fore Colour.blue "  writing ", Colour.fore Colour.red jsFilePath ]
  log [ Colour.fore Colour.blue "  writing ", Colour.fore Colour.red pursFilePath ]

  FS.writeTextFile UTF8 jsFilePath $
    String.joinWith "\n"
      [ "// Do not edit, this file was autogenerated by generate-halogen-css-modules"
      , "exports.styles = require('./" <> Path.basename filePath <> "').default"
      ]

  FS.writeTextFile UTF8 pursFilePath $
    let
      imports = String.joinWith "\n" $
        Array.mapWithIndex (\index className ->
          (if index == 0 then "  { " else "  , ") <> className <> " :: ClassName"
        ) classNames
      styles =
        if Array.length classNames == 0
          then "foreign import styles :: {}"
          else "foreign import styles ::\n" <> imports <> "\n  }"
    in
      String.joinWith "\n"
        [ "-- Do not edit, this file was autogenerated by generate-halogen-css-modules"
        , "module " <> String.joinWith "." (map NonEmptyText.toString $ NonEmpty.toArray $ unModuleName moduleName) <> " (styles) where"
        , ""
        , "import Halogen.HTML (ClassName)"
        , ""
        , styles
        ]
